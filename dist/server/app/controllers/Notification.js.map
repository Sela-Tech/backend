{"version":3,"sources":["../../../../app/controllers/Notification.js"],"names":["require","config","mongoose","Notificate","model","User","Notifications","req","res","user","userId","find","sort","createdAt","notifications","length","map","n","_id","read","stakeholder","message","project","name","id","onModel","type","action","createdOn","updatedOn","updatedAt","unreadNIds","filter","status","json","console","log","ids","body","successRes","success","failRes","updateMany","$set","Boolean","data","module","exports"],"mappings":"AAAA;;;;;;;;;;AACAA,QAAQ,QAAR,EAAkBC,MAAlB;AACA,IAAMC,WAAWF,QAAQ,UAAR,CAAjB;AAAA,IACIG,aAAaD,SAASE,KAAT,CAAe,cAAf,CADjB;AAEA,IAAMC,OAAOH,SAASE,KAAT,CAAe,MAAf,CAAb;;AAGA;;;;;;IAKME,a;;;;;;;;;AAGF;;;;;;;;;;gGASkCC,G,EAAKC,G;;;;;;AAC/BC,oC,GAAOF,IAAIG,M;;;uCAEeP,WAAWQ,IAAX,CAAgB,EAAEF,UAAF,EAAhB,EAA0BG,IAA1B,CAA+B,EAAEC,WAAW,CAAC,CAAd,EAA/B,C;;;AAAtBC,6C;;sCAEAA,cAAcC,MAAd,GAAuB,C;;;;;AACvBD,gDAAgBA,cAAcE,GAAd,CAAkB,UAACC,CAAD,EAAO;AACrC,2CAAO;AACHC,6CAAKD,EAAEC,GADJ;AAEHC,8CAAMF,EAAEE,IAFL;AAGHC,qDAAaH,EAAEG,WAHZ;AAIHC,iDAASJ,EAAEI,OAJR;AAKHZ,8CAAMQ,EAAER,IALL;AAMHa,iDAAS;AACLC,kDAAMN,EAAEK,OAAF,CAAUC,IADX;AAELC,gDAAIP,EAAEK,OAAF,CAAUJ;AAFT,yCANN;AAUHd,+CAAMa,EAAEb,KAVL;AAWHqB,iDAAQR,EAAEQ,OAXP;AAYHC,8CAAMT,EAAES,IAZL;AAaHC,gDAAQV,EAAEU,MAbP;AAcHC,mDAAWX,EAAEJ,SAdV;AAeHgB,mDAAWZ,EAAEa;;AAfV,qCAAP;AAkBH,iCAnBe,CAAhB;;AAqBA;AACMC,0C,GAAajB,cAAckB,MAAd,CAAqB;AAAA,2CAAKf,EAAEE,IAAF,KAAW,KAAhB;AAAA,iCAArB,EAA4CH,GAA5C,CAAgD;AAAA,2CAAKC,EAAEC,GAAP;AAAA,iCAAhD,C;iEAEZV,IAAIyB,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,EAAEpB,4BAAF,EAAiBiB,sBAAjB,EAArB,C;;;iEAGAvB,IAAIyB,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,EAAEb,SAAS,yCAAX,EAArB,C;;;;;;;;;;AAIXc,wCAAQC,GAAR;iEACO5B,IAAIyB,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,EAAEb,SAAS,uBAAX,EAArB,C;;;;;;;;;;;;;;;;;AAOf;;;;;;;;;;;;;kGASoCd,G,EAAKC,G;;;;;;AAC/B6B,mC,GAAM9B,IAAI+B,IAAJ,CAASP,U;AAEjBQ,0C,GAAa,EAAEC,SAAS,IAAX,E;AACbC,uC,GAAU,EAAED,SAAS,KAAX,E;;;sCAGNH,OAAOA,IAAItB,MAAJ,GAAa,C;;;;;;uCAEMZ,WAAWuC,UAAX,CAAsB,EAAExB,kCAASmB,GAAT,EAAF,EAAtB,EAAyC,EAAEM,MAAM,EAAExB,MAAM,IAAR,EAAR,EAAzC,C;;;AAAtBL,6C;;qCAEA8B,QAAQ9B,cAAcG,CAAtB,C;;;;;kEACOT,IAAIyB,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,EAAEK,sBAAF,EAArB,C;;;;;;;kEAIJ/B,IAAIyB,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,EAAEb,SAAS,kCAAX,EAArB,C;;;;;;;;;;AAGXc,wCAAQC,GAAR;AACAK,wCAAQpB,OAAR,GAAkB,uBAAlB;kEACOb,IAAIyB,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,EAAEO,gBAAF,EAArB,C;;;;;;;;;;;;;;;;;AAOf;;;;;;;;;;;;kGAQ+BI,I;;;;;;AACrBpC,oC,GAAOoC,KAAKnC,M;;;uCAEYP,WAAWQ,IAAX,CAAgB,EAAEF,UAAF,EAAQU,MAAM,KAAd,EAAhB,C;;;AAAtBL,6C;;sCAEAA,cAAcC,MAAd,GAAuB,C;;;;;AACvBD,gDAAgBA,cAAcE,GAAd,CAAkB,UAACC,CAAD,EAAO;AACrC,2CAAO;AACHC,6CAAKD,EAAEC,GADJ;AAEHC,8CAAMF,EAAEE,IAFL;AAGHC,qDAAaH,EAAEG,WAHZ;AAIHC,iDAASJ,EAAEI,OAJR;AAKHZ,8CAAMQ,EAAER,IALL;AAMHa,iDAAS;AACLC,kDAAMN,EAAEK,OAAF,CAAUC,IADX;AAELC,gDAAIP,EAAEK,OAAF,CAAUJ;AAFT,yCANN;AAUHQ,8CAAMT,EAAES,IAVL;AAWHC,gDAAQV,EAAEU,MAXP;AAYHvB,+CAAMa,EAAEb,KAZL;AAaHqB,iDAAQR,EAAEQ,OAbP;AAcHG,mDAAWX,EAAEJ,SAdV;AAeHgB,mDAAWZ,EAAEa;;AAfV,qCAAP;AAmBH,iCApBe,CAAhB;;AAsBA;AACMC,0C,GAAajB,cAAckB,MAAd,CAAqB;AAAA,2CAAKf,EAAEE,IAAF,KAAW,KAAhB;AAAA,iCAArB,EAA4CH,GAA5C,CAAgD;AAAA,2CAAKC,EAAEC,GAAP;AAAA,iCAAhD,C;kEAEZ,EAAEJ,4BAAF,EAAiBiB,sBAAjB,E;;;kEAGA,EAAEV,SAAS,yCAAX,E;;;;;;;;;;AAIXc,wCAAQC,GAAR;kEACO,EAAEf,SAAS,uBAAX,E;;;;;;;;;;;;;;;;;;;;;AASnByB,OAAOC,OAAP,GAAiBzC,aAAjB","file":"Notification.js","sourcesContent":["\"use strict\";\nrequire(\"dotenv\").config();\nconst mongoose = require(\"mongoose\"),\n    Notificate = mongoose.model(\"Notification\");\nconst User = mongoose.model(\"User\");\n\n\n/**\n *\n *\n * @class Stakeholder\n */\nclass Notifications {\n\n\n    /**\n     *\n     *\n     * @static\n     * @param {*} req\n     * @param {*} res\n     * @returns\n     * @memberof Notifications\n     */\n    static async getUserNotifications(req, res) {\n        let user = req.userId\n        try {\n            let notifications = await Notificate.find({ user }).sort({ createdAt: -1 });\n\n            if (notifications.length > 0) {\n                notifications = notifications.map((n) => {\n                    return {\n                        _id: n._id,\n                        read: n.read,\n                        stakeholder: n.stakeholder,\n                        message: n.message,\n                        user: n.user,\n                        project: {\n                            name: n.project.name,\n                            id: n.project._id\n                        },\n                        model:n.model,\n                        onModel:n.onModel,\n                        type: n.type,\n                        action: n.action,\n                        createdOn: n.createdAt,\n                        updatedOn: n.updatedAt\n\n                    }\n                });\n\n                //extract unread notitifications\n                const unreadNIds = notifications.filter(n => n.read === false).map(n => n._id);\n\n                return res.status(200).json({ notifications, unreadNIds })\n\n            } else {\n                return res.status(404).json({ message: \"You currently have no new notifications\" });\n            }\n\n        } catch (error) {\n            console.log(error)\n            return res.status(500).json({ message: \"Internal server error\" });\n\n        }\n\n    }\n\n\n    /**\n     *\n     *\n     * @static\n     * @param {*} req\n     * @param {*} res\n     * @returns\n     * @memberof Notifications\n     */\n    static async markNotificationAsRead(req, res) {\n        const ids = req.body.unreadNIds;\n\n        let successRes = { success: true };\n        let failRes = { success: false };\n\n        try {\n            if (ids && ids.length > 0) {\n\n                let notifications = await Notificate.updateMany({ _id: [...ids] }, { $set: { read: true } });\n\n                if (Boolean(notifications.n)) {\n                    return res.status(200).json({ successRes });\n                }\n\n            } else {\n                return res.status(404).json({ message: \"You have no unread notifications\" });\n            }\n        } catch (error) {\n            console.log(error)\n            failRes.message = \"Internal server error\"\n            return res.status(500).json({ failRes });\n        }\n\n    }\n\n\n\n    /**\n     *\n     *\n     * @static\n     * @param {*} data\n     * @returns\n     * @memberof Notifications\n     */\n    static async getUserNViaSocket(data) {\n        const user = data.userId;\n        try {\n            let notifications = await Notificate.find({ user, read: false });\n\n            if (notifications.length > 0) {\n                notifications = notifications.map((n) => {\n                    return {\n                        _id: n._id,\n                        read: n.read,\n                        stakeholder: n.stakeholder,\n                        message: n.message,\n                        user: n.user,\n                        project: {\n                            name: n.project.name,\n                            id: n.project._id\n                        },\n                        type: n.type,\n                        action: n.action,\n                        model:n.model,\n                        onModel:n.onModel,\n                        createdOn: n.createdAt,\n                        updatedOn: n.updatedAt\n\n                    }\n\n                });\n\n                //extract unread notitifications\n                const unreadNIds = notifications.filter(n => n.read === false).map(n => n._id);\n\n                return { notifications, unreadNIds }\n\n            } else {\n                return { message: \"You currently have no new notifications\" };\n            }\n\n        } catch (error) {\n            console.log(error)\n            return { message: \"Internal server error\" };\n\n        }\n\n    }\n\n\n}\n\nmodule.exports = Notifications;"]}